(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{190:function(t,a,r){"use strict";r.r(a);var s=r(0),e=Object(s.a)({},function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"第2章-let和const命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第2章-let和const命令","aria-hidden":"true"}},[t._v("#")]),t._v(" 第2章 let和const命令")]),t._v(" "),r("h2",{attrs:{id:"一、let命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、let命令","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、let命令")]),t._v(" "),r("h3",{attrs:{id:"_1、基本用法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、基本用法","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、基本用法")]),t._v(" "),r("p",[t._v("所声明变量只在代码块内有效")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("let a = 10;\n")])])]),r("h3",{attrs:{id:"_2、不存在变量提升"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、不存在变量提升","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、不存在变量提升")]),t._v(" "),r("p",[t._v("什么是变量提升？变量提升是变量在声明之前使用。let不存在该现象，var存在；如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("后续补充...\n")])])]),r("h3",{attrs:{id:"_3、暂时性死区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、暂时性死区","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、暂时性死区")]),t._v(" "),r("p",[t._v("let声明变量绑定区域，不再受外部影响\nES6明确规定，如果区域内存在let或const命令，则这个区域对这些命令明确的变量从一开始就形成封闭作用于，只要在声明之前使用这些变量就会报错。")]),t._v(" "),r("h3",{attrs:{id:"_4、不允许块内重复声明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、不允许块内重复声明","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、不允许块内重复声明")]),t._v(" "),r("h2",{attrs:{id:"二、块级作用域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、块级作用域","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、块级作用域")]),t._v(" "),r("p",[t._v("ES5中没有块级作用域，导致很多场景不合理。比如：")]),t._v(" "),r("p",[t._v("1、内置变量可能会覆盖外层变量；")]),t._v(" "),r("p",[t._v("2、用来技术的循环遍历泄露为全局变量；")]),t._v(" "),r("h2",{attrs:{id:"三、const命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、const命令","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、const命令")]),t._v(" "),r("h3",{attrs:{id:"_1、基本用法-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、基本用法-2","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、基本用法")]),t._v(" "),r("p",[t._v("const声明变量，不可变，不提升，存在暂时性死区")]),t._v(" "),r("h3",{attrs:{id:"_2、本质"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、本质","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、本质")]),t._v(" "),r("p",[t._v("const实际上保证的不是变量的值不变，二是变量指向的那个内存地址不变，即保证指针是固定的。至于它指向的数据结构是不是可变的完全不能控制，因此，讲一个对象声明为常量需要非常小心。")]),t._v(" "),r("p",[t._v("对象冻结，这个知识点以后再补充...")]),t._v(" "),r("h3",{attrs:{id:"_3、es6声明变量的6种方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、es6声明变量的6种方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、ES6声明变量的6种方法")]),t._v(" "),r("p",[t._v("var、function、let、const、import、class")]),t._v(" "),r("h3",{attrs:{id:"_4、顶层对象的属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、顶层对象的属性","aria-hidden":"true"}},[t._v("#")]),t._v(" 4、顶层对象的属性")]),t._v(" "),r("p",[t._v("什么是顶层对象？")]),t._v(" "),r("p",[t._v("ES6中，为了保持兼容性，var和function命令声明的全局变量依旧是顶层对象的属性，另一方面，let、const、class声明的全局变量不属于顶层对象的属性。")])])},[],!1,null,null,null);a.default=e.exports}}]);